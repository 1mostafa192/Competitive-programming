 #include <bits/stdc++.h>
using namespace std;
#define ll long long 
  const ll MOD = 1e9 + 7;
    const int N=1e5+5;
const int sz=1e6+10;
//------------------------------------------------------------------------------------------------
ll gcd(ll X,ll Y)
{
    if(X<Y) swap(X,Y);
    if(Y==0) return X;
    return gcd(X%Y,Y); 
}

ll lcm(ll X,ll Y)
{
    return (X*Y)/gcd(X,Y);
}


    //                         Lcm three factors

ll lcm_calc(ll a, ll b) {
return a / __gcd(a, b) * b;
}
ll LCM3(ll a, ll b, ll c) {
return lcm_calc(a, lcm_calc(b, c));
}
//----------------------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------------------
bool isprime(ll x)
{
    if(x==1) return 0;
    if(x==2) return 1;

    for(int counter=2;counter*counter<=x;counter++)
    {
        if(x%counter*counter==0) return 0;
    }
    return 1;
}
//----------------------------------------------------------------------------------------------------------
                                //              MOD
    ll add(ll x,ll y ,ll mod) {
    return  ((x%mod)+(y%mod))%mod;
}
ll sub (ll x, ll y,ll mod) {
    return  (((x%mod)-(y%mod))+mod)%mod;
}
ll mul (ll x, ll y, ll mod) {
    return  ((x%mod)*(y%mod))%mod;
}

//----------------------------------------------------------------------------------------------
__int128 fast_power_mod(__int128 x,__int128 b) {
    __int128 res=1;
    while (b>0) {
        if (b%2==1) {
            res=(res*x)%MOD;// MOD if the humber is bigger
        }
        x=(x*x)%MOD;
        b/=2;
    }
    return  res;
}
//----------------------------------------------------------------------------------------------
vector<int>factorization(int number_factor) {
    vector<int>elements;
    for (int i=2;i*i<=number_factor;i++) {
        if (number_factor%i==0) {
            elements.push_back(i);
            if (i*i!=number_factor) {
                elements.push_back(number_factor/i);
            }
        }
    }
    return  elements;
}
//---------------------------------------------------------------------------------------------
vector<int>prime_factorization(int number) {
    vector<int>elements;
    for (int i=2;i*i<=number;i++) {
        while (number%i==0) {
            elements.push_back(i);
            number/=i;
        }
    }
    if (number!=1) elements.push_back(number);
    return elements;
}
//-----------------------------------------------------------------------------------------------
int extendedEuclid_recursive(int a, int b, int &x,int &y) {
    if (b==0) {
        x=1;
        y=0;
        return  a;
    }
    int x1,y1;
    int oper=extendedEuclid_recursive(b,a%b,x1,y1);
    x=y1;
    y=x1-y1*(a/b);
    return  oper;
}
//----------------------------------------------------------------------------------------------
int extendedEuclid_iterative(int a, int b, int& x_prev, int& y_prev)
{
    x_prev=1,y_prev=0;
    int x=0,y=1;
    while (b) {
        int q=a/b;
        tie(x,x_prev)=make_tuple(x_prev-q*x,x);
        tie(y,y_prev)=make_tuple(y_prev-q*y,y);
        tie(a,b)=make_tuple(b,a%b);

    }

    return a;
}
//----------------------------------------------------------------------------------------------------
ll modularExponentiation_lastmodified(ll A,ll B,ll M) {
    ll result =1;
    while (B>0) {
        if (B%2==1) {
            result=(A*result)%M;
        }
        A=(A*A)%M;
        B/=2;
    }
    return  result;
}
//------------------------------------------------------------------------------------------------------------
bool composite[sz+1];
void sieve() {
    composite[0]=composite[1]=1;
    for (int i=2;i*i<sz;i++) {
        if (!composite[i]) {
            for (int j=i*i;j<=sz;j+=i) {
                composite[j]=1;
            }
        }
    }
}
//----------------------------------------------------------------------------------------------------------
vector<int>prime;
void linear_sieve()
{
    composite[0]=composite[1]=1;
    for (int i=2; i<=sz; ++i)
    {
        if (!composite[i])
        {
            prime.push_back(i);
        }
        for (int j=0; j<(int)prime.size()&&i*prime[j]<=sz; ++j)
        {
            composite[i * prime[j]] = 1;
            if (i%prime[j]==0) break;

        }
    }
}

//-------------------------------------------------------------------------------------------------------------

int main(){























    return 0;
}